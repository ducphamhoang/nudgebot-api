I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current codebase has a solid foundation with all three modules (chatbot, LLM, nudge) properly integrated through an event-driven architecture. The nudge service creates reminders in the database and has business logic for calculating reminder times, but there's no background process to actually poll for due reminders and trigger them. The GORM repository has `GetDueReminders` and `MarkReminderSent` methods implemented, and the `ReminderManager` has logic for calculating nudge times with exponential backoff. The event bus is thread-safe and supports graceful shutdown. The configuration system is extensible and ready for scheduler-specific settings.

### Approach

I'll create a background scheduler module that runs as goroutines to poll the database for due reminders and publish `ReminderDue` events. The approach focuses on:

- **Scheduler Service**: Create a dedicated scheduler service with configurable polling intervals and worker goroutines
- **Database Polling**: Use the existing `GetDueReminders` repository method to fetch due reminders
- **Event Publishing**: Publish `ReminderDue` events for each due reminder and mark them as sent
- **Nudge System**: Implement 2-hour delay nudge logic by creating follow-up reminders after initial reminders are sent
- **Graceful Shutdown**: Integrate with the existing server shutdown sequence using context cancellation
- **Configuration**: Add scheduler-specific configuration options for polling intervals and nudge delays

The implementation maintains the existing clean architecture while adding the missing background processing capability.

### Reasoning

I explored the current codebase structure including the main server initialization, configuration system, event bus implementation, nudge service with reminder management, GORM repository with reminder operations, and business logic components. I analyzed the existing event types and found that `ReminderDue` events are defined but not being triggered by any background process. The analysis revealed that while the foundation is solid with proper interfaces and database operations, the actual background scheduler to poll for due reminders and trigger the nudge system is missing.

## Mermaid Diagram

sequenceDiagram
    participant Main as main.go
    participant Scheduler as Scheduler Service
    participant Worker as Reminder Worker
    participant Repo as NudgeRepository
    participant EB as EventBus
    participant CB as ChatbotService
    participant DB as Database

    Note over Main,DB: Server Startup & Scheduler Initialization
    Main->>Scheduler: NewScheduler(config, repository, eventBus, logger)
    Main->>Scheduler: Start(ctx) in goroutine
    Scheduler->>Scheduler: Create ticker with poll_interval
    Scheduler->>Worker: Start worker goroutines (worker_count)

    Note over Worker,DB: Background Reminder Processing Loop
    loop Every poll_interval (30s default)
        Worker->>Repo: GetDueReminders(time.Now())
        Repo->>DB: SELECT * FROM reminders WHERE scheduled_at <= ? AND sent_at IS NULL
        DB-->>Repo: Return due reminders
        Repo-->>Worker: List of due reminders

        loop For each due reminder
            Worker->>EB: Publish ReminderDue event
            EB->>CB: Handle ReminderDue (send notification)
            Worker->>Repo: MarkReminderSent(reminderID)
            Repo->>DB: UPDATE reminders SET sent_at = NOW()
            
            Note over Worker: Check if nudge needed
            Worker->>Worker: shouldCreateNudge(reminder, task)
            alt If nudge needed (initial reminder + task active + under max nudges)
                Worker->>Worker: createNudgeReminder(reminder, task)
                Worker->>Repo: CreateReminder(nudgeReminder with +2h delay)
                Repo->>DB: INSERT nudge reminder for later processing
            end
        end
    end

    Note over Main,DB: Graceful Shutdown
    Main->>Scheduler: Stop() (on SIGTERM/SIGINT)
    Scheduler->>Scheduler: Cancel context & stop ticker
    Scheduler->>Worker: Wait for workers to finish (with timeout)
    Worker->>Worker: Complete current processing & exit
    Scheduler-->>Main: Shutdown complete
    Main->>EB: Close event bus

## Proposed File Changes

### internal/config/config.go(MODIFY)

Add `SchedulerConfig` struct to the main `Config` struct with fields for polling configuration:

- Add `Scheduler SchedulerConfig \`mapstructure:"scheduler"\`` field to the main Config struct
- Create `SchedulerConfig` struct with fields:
  - `PollInterval int \`mapstructure:"poll_interval"\`` for polling frequency in seconds
  - `NudgeDelay int \`mapstructure:"nudge_delay"\`` for delay between nudges in seconds (default 7200 for 2 hours)
  - `WorkerCount int \`mapstructure:"worker_count"\`` for number of worker goroutines
  - `ShutdownTimeout int \`mapstructure:"shutdown_timeout"\`` for graceful shutdown timeout
  - `Enabled bool \`mapstructure:"enabled"\`` to enable/disable the scheduler

- Update `setDefaults()` function to include scheduler defaults:
  - `viper.SetDefault("scheduler.poll_interval", 30)` // 30 seconds
  - `viper.SetDefault("scheduler.nudge_delay", 7200)` // 2 hours
  - `viper.SetDefault("scheduler.worker_count", 2)`
  - `viper.SetDefault("scheduler.shutdown_timeout", 30)`
  - `viper.SetDefault("scheduler.enabled", true)`

The configuration follows the same patterns as existing config sections and provides sensible defaults for production use.

### internal/scheduler(NEW)

Create the scheduler directory to house the background reminder processing system.

### internal/scheduler/scheduler.go(NEW)

References: 

- internal/config/config.go(MODIFY)
- internal/nudge/repository.go
- internal/events/bus.go

Create the main scheduler service with interface and implementation:

- Define `Scheduler` interface with methods:
  - `Start(ctx context.Context) error` for starting the scheduler
  - `Stop() error` for graceful shutdown
  - `IsRunning() bool` for status checking

- Implement `scheduler` struct with fields:
  - `config SchedulerConfig` for configuration
  - `repository nudge.NudgeRepository` for database access
  - `eventBus events.EventBus` for publishing events
  - `logger *zap.Logger` for logging
  - `ctx context.Context` and `cancel context.CancelFunc` for cancellation
  - `wg sync.WaitGroup` for goroutine management
  - `ticker *time.Ticker` for polling intervals
  - `running atomic.Bool` for thread-safe status tracking

- Implement `NewScheduler(config SchedulerConfig, repository nudge.NudgeRepository, eventBus events.EventBus, logger *zap.Logger) Scheduler` constructor

- Implement `Start(ctx context.Context)` method that:
  - Creates a ticker with the configured poll interval
  - Starts worker goroutines based on worker count configuration
  - Each worker listens for ticker events and processes due reminders
  - Uses context cancellation for graceful shutdown
  - Includes proper error handling and logging

- Implement `Stop()` method that:
  - Cancels the context to signal shutdown
  - Stops the ticker
  - Waits for all worker goroutines to complete with timeout
  - Logs shutdown completion

Reference the configuration from `internal/config/config.go`, repository interface from `internal/nudge/repository.go`, and event bus from `internal/events/bus.go`.

### internal/scheduler/worker.go(NEW)

References: 

- internal/nudge/domain.go
- internal/nudge/business_logic.go
- internal/events/types.go

Create the worker implementation for processing due reminders:

- Implement `reminderWorker` struct with fields for scheduler dependencies

- Implement `processReminders()` method that:
  - Calls `repository.GetDueReminders(time.Now())` to fetch due reminders
  - For each due reminder:
    - Publishes `ReminderDue` event with reminder details
    - Calls `repository.MarkReminderSent(reminder.ID)` to mark as sent
    - Determines if a follow-up nudge should be created using business logic
    - If nudge is needed, creates a new reminder with `ReminderTypeNudge` scheduled for `+nudgeDelay` time
  - Includes comprehensive error handling for each step
  - Logs processing statistics (reminders processed, nudges created, errors)

- Implement `shouldCreateNudge(reminder *Reminder, task *Task)` helper method that:
  - Checks if the reminder is of type `ReminderTypeInitial`
  - Verifies the task is still active and can be nudged
  - Counts existing nudges for the task to respect max nudge limits
  - Uses the existing business logic from `ReminderManager.ShouldCreateNudge`

- Implement `createNudgeReminder(originalReminder *Reminder, task *Task)` helper method that:
  - Calculates the next nudge time using the configured nudge delay (2 hours)
  - Creates a new `Reminder` with `ReminderTypeNudge`
  - Calls `repository.CreateReminder()` to schedule the nudge
  - Handles errors and logs nudge creation

- Include proper correlation ID tracking for debugging and monitoring
- Add metrics tracking for reminder processing performance

Reference the reminder domain models from `internal/nudge/domain.go`, business logic from `internal/nudge/business_logic.go`, and event types from `internal/events/types.go`.

### internal/scheduler/errors.go(NEW)

References: 

- internal/common/types.go

Create comprehensive error handling for the scheduler module:

- Define `SchedulerError` interface with methods `Code() string`, `Message() string`, and `Temporary() bool`

- Implement specific error types:
  - `ReminderProcessingError` for failures during reminder processing with reminder ID and operation context
  - `NudgeCreationError` for failures when creating follow-up nudge reminders
  - `WorkerError` for worker goroutine failures with worker ID and error details
  - `ShutdownError` for graceful shutdown failures with timeout information
  - `ConfigurationError` for invalid scheduler configuration

- Define error constants:
  - `ErrSchedulerNotRunning`, `ErrSchedulerAlreadyRunning`, `ErrInvalidConfiguration`
  - `ErrReminderProcessingFailed`, `ErrNudgeCreationFailed`, `ErrWorkerPanic`

- Implement error wrapping utilities:
  - `WrapReminderError(err error, reminderID string, operation string) error`
  - `WrapWorkerError(err error, workerID int, operation string) error`
  - `NewSchedulerError(code string, message string) error`

- Add error classification helpers:
  - `IsRetryableError(err error) bool` for determining if operations should be retried
  - `IsTemporaryError(err error) bool` for transient failures
  - `IsConfigurationError(err error) bool` for configuration-related failures

- Include error recovery strategies for different failure modes
- Add error metrics and alerting hooks for production monitoring

The error system should provide clear categorization for different failure modes and integrate with the existing logging system for debugging.

### cmd/server/main.go(MODIFY)

References: 

- internal/scheduler/scheduler.go(NEW)

Integrate the scheduler into the main server initialization and shutdown sequence:

- Add import for the scheduler package: `"nudgebot-api/internal/scheduler"`

- After nudge service initialization (around line 60), add scheduler initialization:
  ```go
  // Initialize scheduler
  if cfg.Scheduler.Enabled {
      reminderScheduler := scheduler.NewScheduler(cfg.Scheduler, nudgeRepository, eventBus, zapLogger)
      
      // Start scheduler in background
      go func() {
          if err := reminderScheduler.Start(context.Background()); err != nil {
              logger.Error("Scheduler failed to start", "error", err)
          }
      }()
      
      logger.Info("Reminder scheduler started", 
          "poll_interval", cfg.Scheduler.PollInterval,
          "nudge_delay", cfg.Scheduler.NudgeDelay,
          "worker_count", cfg.Scheduler.WorkerCount)
  } else {
      logger.Info("Reminder scheduler disabled")
  }
  ```

- Update the graceful shutdown sequence (around line 115) to stop the scheduler before closing the event bus:
  ```go
  logger.Info("Shutting down server...")
  
  // Stop scheduler first
  if cfg.Scheduler.Enabled {
      logger.Info("Stopping reminder scheduler...")
      if err := reminderScheduler.Stop(); err != nil {
          logger.Error("Failed to stop scheduler gracefully", "error", err)
      } else {
          logger.Info("Reminder scheduler stopped successfully")
      }
  }
  
  // Then stop event processing...
  ```

- Store the scheduler instance in a variable accessible to the shutdown sequence
- Maintain the existing error handling patterns and logging
- Ensure the scheduler starts after all other services are initialized

Reference the scheduler constructor from `internal/scheduler/scheduler.go` and maintain the existing server startup flow.

### configs/config.yaml(MODIFY)

Add the scheduler configuration section to the YAML configuration file:

```yaml
scheduler:
  enabled: true
  poll_interval: 30  # seconds
  nudge_delay: 7200   # 2 hours in seconds
  worker_count: 2
  shutdown_timeout: 30
```

Add this section after the existing nudge configuration. Include comments explaining the purpose of each setting:
- `enabled`: Whether the background reminder scheduler is active
- `poll_interval`: How often to check for due reminders (in seconds)
- `nudge_delay`: Time delay between initial reminder and first nudge (2 hours = 7200 seconds)
- `worker_count`: Number of worker goroutines for processing reminders
- `shutdown_timeout`: Maximum time to wait for graceful shutdown

The configuration provides sensible defaults for production use while allowing customization for different deployment scenarios.

### .env.example(MODIFY)

Add scheduler configuration environment variables to the example file:

```
# Scheduler Configuration
SCHEDULER_ENABLED=true
SCHEDULER_POLL_INTERVAL=30
SCHEDULER_NUDGE_DELAY=7200
SCHEDULER_WORKER_COUNT=2
SCHEDULER_SHUTDOWN_TIMEOUT=30
```

Add this section after the existing nudge configuration variables. Include comments explaining the purpose:
- `SCHEDULER_ENABLED`: Enable/disable background reminder processing
- `SCHEDULER_POLL_INTERVAL`: Polling frequency in seconds (30s default)
- `SCHEDULER_NUDGE_DELAY`: Delay between reminders in seconds (2 hours default)
- `SCHEDULER_WORKER_COUNT`: Number of processing workers (2 default)
- `SCHEDULER_SHUTDOWN_TIMEOUT`: Graceful shutdown timeout in seconds

Follow the same naming convention as existing environment variables using uppercase with underscores.

### internal/mocks/scheduler_mocks.go(NEW)

References: 

- internal/scheduler/scheduler.go(NEW)
- internal/mocks/interfaces.go

Create comprehensive mock implementations for testing the scheduler module:

- Add `//go:generate mockgen -source=../scheduler/scheduler.go -destination=scheduler_mocks.go -package=mocks` directive for generating scheduler mocks

- Implement `MockScheduler` struct that implements the `Scheduler` interface:
  - `started atomic.Bool` for tracking state
  - `startError error` for configurable start failures
  - `stopError error` for configurable stop failures
  - `callCounts map[string]int` for tracking method calls
  - Methods that implement the interface with configurable behavior

- Implement `MockReminderProcessor` for testing reminder processing logic:
  - In-memory storage for reminders and processing results
  - Configurable processing delays and error scenarios
  - Call tracking for verification in tests
  - Simulation of database operations and event publishing

- Include helper methods for test setup:
  - `SetStartError(error)` for simulating startup failures
  - `SetStopError(error)` for simulating shutdown failures
  - `GetCallCount(method string) int` for verifying method calls
  - `SimulateProcessingDelay(duration)` for testing timing scenarios
  - `AddDueReminder(reminder)` for setting up test data

- Add factory methods for creating test scenarios:
  - `CreateTestScheduler()` for basic scheduler testing
  - `CreateFailingScheduler()` for error scenario testing
  - `CreateSlowScheduler()` for performance testing

- Include assertion helpers:
  - `AssertStarted(t *testing.T)` for verifying scheduler state
  - `AssertStopped(t *testing.T)` for verifying shutdown
  - `AssertProcessedCount(t *testing.T, expected int)` for verifying processing

The mocks should support both unit testing of individual components and integration testing of the scheduler system. Reference the scheduler interface from `internal/scheduler/scheduler.go` and follow existing mock patterns.

### internal/scheduler/metrics.go(NEW)

Create metrics and monitoring utilities for the scheduler:

- Implement `SchedulerMetrics` struct with fields for tracking:
  - `RemindersProcessed int64` for total reminders processed
  - `NudgesCreated int64` for total nudges created
  - `ProcessingErrors int64` for error count
  - `AverageProcessingTime time.Duration` for performance monitoring
  - `LastProcessingTime time.Time` for health checking
  - `WorkerUtilization map[int]float64` for worker performance

- Implement metrics collection methods:
  - `RecordReminderProcessed(duration time.Duration)` for tracking processing time
  - `RecordNudgeCreated()` for counting nudge creation
  - `RecordProcessingError(err error)` for error tracking
  - `RecordWorkerActivity(workerID int, active bool)` for utilization tracking

- Implement health check methods:
  - `IsHealthy() bool` for determining scheduler health
  - `GetHealthStatus() HealthStatus` for detailed health information
  - `GetMetricsSummary() MetricsSummary` for monitoring dashboards

- Include performance monitoring:
  - Processing rate calculations (reminders per minute)
  - Error rate monitoring (errors per hour)
  - Worker efficiency metrics (active time percentage)
  - Queue depth monitoring (pending reminders)

- Add alerting hooks:
  - `OnHighErrorRate(threshold float64, callback func())` for error alerts
  - `OnSlowProcessing(threshold time.Duration, callback func())` for performance alerts
  - `OnWorkerFailure(callback func(workerID int))` for worker monitoring

- Include metrics export capabilities:
  - JSON export for monitoring systems
  - Prometheus-compatible metrics format
  - Log-based metrics for simple monitoring

The metrics system should provide comprehensive observability for production deployments while being lightweight and non-intrusive.