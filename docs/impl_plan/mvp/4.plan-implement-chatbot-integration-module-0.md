I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current chatbot module has excellent foundations with well-defined domain models, service interfaces, and event subscriptions already in place. The configuration system includes ChatbotConfig with webhook_url, token, and timeout fields. The service currently has TODO implementations for all Telegram API interactions. The event bus system is fully functional and ready for integration. The main server initializes the chatbot service but doesn't pass configuration to it. A Telegram Bot API client dependency needs to be added to go.mod.

### Approach

I'll implement the Telegram Bot API integration by adding a proven client library, creating a provider abstraction layer for testability, and implementing webhook handling through Gin routes. The approach focuses on:

- **Telegram Client Integration**: Add `github.com/go-telegram-bot-api/telegram-bot-api/v5` for robust API interaction
- **Provider Pattern**: Create `TelegramProvider` interface for clean separation and easy testing
- **Webhook Processing**: Implement proper Telegram Update parsing and message extraction
- **Command Processing**: Full implementation of all required commands with inline keyboard support
- **Event Integration**: Seamless integration with existing event-driven architecture
- **Error Handling**: Proper error handling following Telegram's webhook requirements (always return 200)

The implementation maintains the existing clean architecture while adding comprehensive Telegram functionality.

### Reasoning

I explored the current codebase structure including the chatbot module implementation, configuration system, event bus, main server initialization, and existing route patterns. I examined the domain models, service interfaces, and event types to understand the existing architecture. I also checked the current dependencies in go.mod and analyzed how services are currently initialized and wired together. This analysis revealed that while the foundation is solid with proper interfaces and event handling, the actual Telegram API integration is missing.

## Mermaid Diagram

sequenceDiagram
    participant TG as Telegram
    participant WH as Webhook Handler
    participant CS as ChatbotService
    participant TP as TelegramProvider
    participant CP as CommandProcessor
    participant EB as EventBus
    participant NS as NudgeService

    Note over TG,NS: User sends "/start" command
    TG->>WH: POST /api/v1/telegram/webhook
    WH->>CS: HandleWebhook(updateData)
    CS->>CS: ParseUpdate & ExtractMessage
    CS->>CP: ProcessStartCommand(userID, chatID)
    CP->>TP: SendMessage(chatID, welcomeText)
    TP->>TG: sendMessage API call
    TG-->>TP: Message sent confirmation
    CS->>EB: Publish UserSessionStarted event

    Note over TG,NS: User sends task text
    TG->>WH: POST /api/v1/telegram/webhook
    WH->>CS: HandleWebhook(updateData)
    CS->>CS: ParseUpdate & ExtractMessage
    CS->>EB: Publish MessageReceived event
    EB->>NS: Handle MessageReceived (via LLM)
    
    Note over NS,EB: Task parsed and created
    EB->>CS: TaskParsed event received
    CS->>CS: BuildTaskActionKeyboard(taskID)
    CS->>TP: SendMessageWithKeyboard(chatID, confirmText, keyboard)
    TP->>TG: sendMessage with inline keyboard
    
    Note over TG,NS: User clicks "Done" button
    TG->>WH: POST /api/v1/telegram/webhook (callback_query)
    WH->>CS: HandleWebhook(callbackData)
    CS->>CS: ExtractCallbackQuery
    CS->>CP: HandleCallbackQuery(action="done", taskID)
    CP->>EB: Publish TaskActionRequested event
    EB->>NS: Handle task completion
    CS->>TP: SendMessage(chatID, "Task completed!")
    TP->>TG: sendMessage API call

    Note over TG,NS: User sends "/list" command
    TG->>WH: POST /api/v1/telegram/webhook
    WH->>CS: HandleWebhook(updateData)
    CS->>CP: ProcessListCommand(userID, chatID)
    CP->>EB: Publish TaskListRequested event
    EB->>NS: Handle task list request
    NS->>EB: Publish TaskListResponse event
    EB->>CS: Handle TaskListResponse
    CS->>CS: BuildTaskListKeyboard(tasks)
    CS->>TP: SendMessageWithKeyboard(chatID, taskList, keyboard)
    TP->>TG: sendMessage with task list

## Proposed File Changes

### go.mod(MODIFY)

Add the `github.com/go-telegram-bot-api/telegram-bot-api/v5 v5.5.1` dependency for Telegram Bot API integration. This is a mature, well-maintained library that provides comprehensive Telegram Bot API support with proper error handling, webhook support, and all necessary types for bot development.

### internal/chatbot/provider.go(NEW)

Create the `TelegramProvider` interface that defines the contract for Telegram API operations:

- `SendMessage(chatID int64, text string) error` for sending plain text messages
- `SendMessageWithKeyboard(chatID int64, text string, keyboard tgbotapi.InlineKeyboardMarkup) error` for messages with inline keyboards
- `SetWebhook(webhookURL string) error` for webhook configuration
- `DeleteWebhook() error` for webhook cleanup
- `GetMe() (*tgbotapi.User, error)` for bot information and health checks

Define a `TelegramConfig` struct with fields for bot token, webhook URL, timeout, and retry settings. This abstraction allows the service to work with different Telegram implementations and enables comprehensive testing with mocks.

### internal/chatbot/telegram_provider.go(NEW)

References: 

- internal/chatbot/provider.go(NEW)
- internal/config/config.go

Implement the `telegramProvider` struct that implements the `TelegramProvider` interface using the telegram-bot-api library:

- `telegramProvider` struct with fields for bot API instance, logger, and configuration
- `NewTelegramProvider(config ChatbotConfig, logger *zap.Logger) (TelegramProvider, error)` constructor that creates and validates the bot instance
- `SendMessage` implementation that creates `MessageConfig` and calls `bot.Send()`
- `SendMessageWithKeyboard` implementation that attaches inline keyboard markup
- `SetWebhook` implementation using `WebhookConfig` with proper URL validation
- `DeleteWebhook` implementation for cleanup during shutdown
- `GetMe` implementation for bot validation and health checks
- Comprehensive error handling with retry logic for transient failures
- Proper timeout configuration using the provided timeout settings
- Logging for all API calls with correlation IDs for debugging

The implementation should handle rate limiting, network errors, and invalid responses gracefully. Reference the configuration from `internal/config/config.go` and use structured logging throughout.

### internal/chatbot/webhook_parser.go(NEW)

References: 

- internal/chatbot/domain.go
- internal/common/types.go

Create webhook parsing utilities for converting Telegram updates to domain models:

- `WebhookParser` struct with methods for parsing different update types
- `ParseUpdate(updateData []byte) (*tgbotapi.Update, error)` for JSON unmarshaling with validation
- `ExtractMessage(update *tgbotapi.Update) (*Message, error)` for converting Telegram messages to domain Message struct
- `ExtractCallbackQuery(update *tgbotapi.Update) (*CallbackData, error)` for parsing inline keyboard callbacks
- `DetermineMessageType(update *tgbotapi.Update) MessageType` for classifying messages as command, text, or callback
- `ExtractCommand(message *tgbotapi.Message) (Command, error)` for parsing bot commands
- `BuildCorrelationID(update *tgbotapi.Update) string` for generating unique correlation IDs

Include comprehensive validation for required fields, proper error handling for malformed updates, and logging for debugging. The parser should handle edge cases like edited messages, channel posts, and unknown update types gracefully. Reference the domain models from `internal/chatbot/domain.go` and common types from `internal/common/types.go`.

### internal/chatbot/keyboard_builder.go(NEW)

References: 

- internal/chatbot/domain.go

Create utilities for building inline keyboards for task management:

- `KeyboardBuilder` struct with methods for creating common keyboard layouts
- `BuildTaskActionKeyboard(taskID string) InlineKeyboard` for creating Done/Delete buttons for specific tasks
- `BuildTaskListKeyboard(tasks []TaskSummary) InlineKeyboard` for paginated task lists with action buttons
- `BuildConfirmationKeyboard(action string, taskID string) InlineKeyboard` for confirmation dialogs
- `BuildMainMenuKeyboard() InlineKeyboard` for the main bot menu with common actions
- `BuildPaginationKeyboard(currentPage, totalPages int, baseCallback string) InlineKeyboard` for navigation

Define helper types:
- `TaskSummary` struct with ID, Title, DueDate, and Status for keyboard display
- `CallbackAction` constants for different button actions (DONE, DELETE, CONFIRM, CANCEL, LIST, etc.)

Include utility functions for encoding/decoding callback data as JSON strings, handling pagination logic, and creating user-friendly button text. The keyboards should be intuitive and follow Telegram's best practices for inline keyboards. Reference the domain models from `internal/chatbot/domain.go`.

### internal/chatbot/command_processor.go(NEW)

References: 

- internal/chatbot/domain.go
- internal/events/types.go(MODIFY)

Create comprehensive command processing logic for all bot commands:

- `CommandProcessor` struct with methods for handling each command type
- `ProcessStartCommand(userID, chatID)` that sends welcome message and sets up user session
- `ProcessHelpCommand(userID, chatID)` that sends comprehensive help text with available commands
- `ProcessListCommand(userID, chatID)` that publishes `TaskListRequested` event and handles the response
- `ProcessDoneCommand(userID, chatID, args)` that handles task completion with optional task ID argument
- `ProcessDeleteCommand(userID, chatID, args)` that handles task deletion with confirmation
- `HandleCallbackQuery(callbackData, userID, chatID)` for processing inline keyboard button presses

Implement session management:
- `SessionManager` struct for tracking user conversation state
- In-memory session storage with cleanup for inactive sessions
- State transitions for multi-step commands (e.g., selecting task to complete)

Include comprehensive error handling, user-friendly error messages, and proper event publishing for commands that require interaction with other modules. The processor should handle edge cases like invalid arguments, missing tasks, and concurrent operations. Reference the domain models from `internal/chatbot/domain.go` and event types from `internal/events/types.go`.

### internal/chatbot/service.go(MODIFY)

References: 

- internal/chatbot/provider.go(NEW)
- internal/chatbot/telegram_provider.go(NEW)
- internal/chatbot/webhook_parser.go(NEW)
- internal/chatbot/keyboard_builder.go(NEW)
- internal/chatbot/command_processor.go(NEW)
- internal/config/config.go

Update the chatbot service to use the new Telegram provider and implement all TODO methods:

- Add `provider TelegramProvider`, `parser *WebhookParser`, `keyboardBuilder *KeyboardBuilder`, `commandProcessor *CommandProcessor`, and `config ChatbotConfig` fields to the `chatbotService` struct
- Update `NewChatbotService(eventBus events.EventBus, logger *zap.Logger, config config.ChatbotConfig)` constructor signature to accept configuration
- In the constructor, create instances of all components: `NewTelegramProvider(config.Chatbot, logger)`, `NewWebhookParser()`, `NewKeyboardBuilder()`, `NewCommandProcessor()`
- Implement `SendMessage` method by delegating to `provider.SendMessage()`
- Implement `SendMessageWithKeyboard` method by converting domain `InlineKeyboard` to `tgbotapi.InlineKeyboardMarkup` and calling `provider.SendMessageWithKeyboard()`
- Implement `HandleWebhook` method by:
  - Using `parser.ParseUpdate()` to parse the webhook data
  - Extracting message information with `parser.ExtractMessage()` or `parser.ExtractCallbackQuery()`
  - Publishing appropriate events (`MessageReceived` for text, command processing for commands, callback handling for buttons)
- Implement `ProcessCommand` method by delegating to `commandProcessor.ProcessCommand()`
- Update event handlers `handleTaskParsed` and `handleReminderDue` to send actual messages using the provider
- Add webhook setup during service initialization if webhook URL is configured
- Include comprehensive error handling and logging throughout

Maintain backward compatibility with the existing service interface while adding the new functionality. Reference the provider interface from `internal/chatbot/provider.go` and other new components.

### api/handlers/webhook.go(NEW)

References: 

- internal/chatbot/service.go(MODIFY)
- api/handlers/health.go

Create a webhook handler for processing Telegram updates:

- `WebhookHandler` struct with fields for chatbot service and logger
- `NewWebhookHandler(chatbotService chatbot.ChatbotService, logger *logger.Logger) *WebhookHandler` constructor
- `HandleTelegramWebhook(c *gin.Context)` method that:
  - Reads the raw request body
  - Validates the request (optional: verify Telegram signature if security is required)
  - Calls `chatbotService.HandleWebhook(body)` to process the update
  - Always returns HTTP 200 status (Telegram requirement)
  - Logs any errors but doesn't return them to Telegram
  - Includes correlation ID for request tracking

The handler should be robust and handle malformed requests gracefully. Include proper error logging for debugging while maintaining the Telegram webhook contract of always returning 200 OK. Reference the chatbot service interface from `internal/chatbot/service.go` and follow the existing handler patterns from `internal/api/handlers/health.go`.

### api/routes/routes.go(MODIFY)

References: 

- api/handlers/webhook.go(NEW)
- internal/chatbot/service.go(MODIFY)

Update the route setup to include the Telegram webhook endpoint:

- Add `chatbotService chatbot.ChatbotService` parameter to the `SetupRoutes` function signature
- Create a webhook handler instance: `webhookHandler := handlers.NewWebhookHandler(chatbotService, logger)`
- Add the webhook route to the v1 API group: `v1.POST("/telegram/webhook", webhookHandler.HandleTelegramWebhook)`
- Optionally add a webhook setup endpoint for development: `v1.POST("/telegram/setup-webhook", webhookHandler.SetupWebhook)` (for configuring the webhook URL with Telegram)

The webhook endpoint should be accessible at `/api/v1/telegram/webhook` and follow the existing route patterns. Ensure the route is properly secured if needed and follows RESTful conventions. Reference the new webhook handler from `api/handlers/webhook.go` and the chatbot service interface.

### cmd/server/main.go(MODIFY)

References: 

- internal/chatbot/service.go(MODIFY)
- api/routes/routes.go(MODIFY)

Update the main server initialization to pass configuration to the chatbot service and include it in route setup:

- Modify the chatbot service initialization (line 54) to include the configuration: `chatbotService := chatbot.NewChatbotService(eventBus, zapLogger, cfg.Chatbot)`
- Update the `routes.SetupRoutes` call (line 71) to pass the chatbot service: `routes.SetupRoutes(router, db, logger, chatbotService)`
- Ensure the configuration is properly loaded and available before service initialization
- Maintain the existing service initialization order and error handling patterns
- Keep all other service initializations unchanged

The changes should be minimal and focused on integrating the chatbot service with the HTTP routing layer while maintaining the existing server startup flow. Reference the updated service constructor from `internal/chatbot/service.go` and the updated route setup function.

### configs/config.yaml(MODIFY)

Add the chatbot configuration section to the YAML configuration file:

```yaml
chatbot:
  webhook_url: "/api/v1/telegram/webhook"
  token: "" # Set via environment variable CHATBOT_TOKEN
  timeout: 30
```

Add this section after the existing database configuration. Include a comment indicating that the token should be set via environment variable for security. Use the webhook endpoint that matches the route definition.

### .env.example(MODIFY)

Add chatbot configuration environment variables to the example file:

```
# Chatbot Configuration
CHATBOT_WEBHOOK_URL=/api/v1/telegram/webhook
CHATBOT_TOKEN=your_telegram_bot_token_here
CHATBOT_TIMEOUT=30
```

Add this section after the existing database configuration variables. Include a placeholder value for the bot token that clearly indicates where users should input their actual Telegram bot token. Follow the same naming convention as existing environment variables.

### internal/chatbot/errors.go(NEW)

References: 

- internal/common/types.go

Create comprehensive error handling for the chatbot module:

- Define `ChatbotError` interface with methods `Code() string`, `Message() string`, and `Temporary() bool`
- Implement specific error types:
  - `TelegramAPIError` for Telegram Bot API failures with HTTP status codes and API error descriptions
  - `WebhookParsingError` for malformed webhook data with details about parsing failures
  - `CommandProcessingError` for command execution failures with command context
  - `ConfigurationError` for invalid bot configuration (missing token, invalid webhook URL)
  - `SessionError` for session management failures
- Include error wrapping utilities:
  - `WrapTelegramError(err error, operation string) error` for API call failures
  - `WrapParsingError(err error, updateType string) error` for webhook parsing failures
  - `NewCommandError(command string, reason string) error` for command processing failures
- Add error classification helpers:
  - `IsRetryableError(err error) bool` for determining if operations should be retried
  - `IsConfigurationError(err error) bool` for configuration-related failures
  - `IsTemporaryError(err error) bool` for transient failures
- Define error constants for common scenarios and HTTP status code mapping

The error system should provide clear categorization for different failure modes and integrate with the existing logging system. Reference the common error patterns from `internal/common/types.go`.

### internal/mocks/chatbot_mocks.go(NEW)

References: 

- internal/chatbot/provider.go(NEW)
- internal/mocks/interfaces.go

Create comprehensive mock implementations for testing the chatbot module:

- Add `//go:generate mockgen -source=../chatbot/provider.go -destination=chatbot_provider_mocks.go -package=mocks` directive for generating provider mocks
- Implement `MockTelegramProvider` struct that implements the `TelegramProvider` interface with configurable responses:
  - In-memory storage for sent messages and keyboard interactions
  - Configurable success/failure responses for different operations
  - Call tracking for verification in tests
  - Simulation of Telegram API rate limiting and errors
- Implement `MockWebhookParser` for testing webhook processing without actual Telegram updates
- Implement `MockCommandProcessor` for testing command logic in isolation
- Include helper methods for test setup:
  - `SetSendMessageResponse(chatID, expectedText, error)` for configuring message sending behavior
  - `GetSentMessages()` for retrieving all messages sent during tests
  - `SimulateWebhookUpdate(updateJSON)` for creating test webhook data
  - `ExpectCommand(command, userID, chatID)` for setting up command expectations
- Add factory methods for creating common test scenarios:
  - `CreateTestMessage(userID, chatID, text)` for message creation
  - `CreateTestCallback(userID, chatID, data)` for callback query creation
  - `CreateTestCommand(command, userID, chatID)` for command testing

The mocks should support both unit testing of individual components and integration testing of the service layer. Reference the provider interface from `internal/chatbot/provider.go` and follow the existing mock patterns from `internal/mocks/interfaces.go`.

### internal/events/types.go(MODIFY)

Add new event types for chatbot-specific operations:

- `TaskListRequested` event with fields: Event (embedded), UserID, ChatID for when users request their task list
- `TaskActionRequested` event with fields: Event (embedded), UserID, ChatID, TaskID, Action (done/delete/snooze) for task management actions
- `UserSessionStarted` event with fields: Event (embedded), UserID, ChatID, SessionType for tracking user interactions
- `CommandExecuted` event with fields: Event (embedded), UserID, ChatID, Command, Success, ErrorMessage for command tracking

Add corresponding topic constants:
- `TopicTaskListRequested = "task.list.requested"`
- `TopicTaskActionRequested = "task.action.requested"`
- `TopicUserSessionStarted = "user.session.started"`
- `TopicCommandExecuted = "command.executed"`

These events enable the chatbot to communicate with other modules for task management operations while maintaining loose coupling. The events follow the same pattern as existing event types and include proper validation tags.