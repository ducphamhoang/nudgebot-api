I have created the following plan after thorough exploration and analysis of the codebase. Follow the below plan verbatim. Trust the files and references. Do not re-verify what's written in the plan. Explore only when absolutely necessary. First implement all the proposed file changes and then I'll review all the changes together at the end.

### Observations

The current implementation has excellent foundations with all three services already implementing event subscriptions and basic event handling. The chatbot service publishes MessageReceived events and handles TaskParsed/ReminderDue events. The LLM service handles MessageReceived and publishes TaskParsed events. The nudge service handles TaskParsed and publishes TaskCreated/TaskCompleted events. However, key missing pieces include: TaskListRequested and TaskActionRequested event handlers in the nudge service, TaskListResponse event type for completing the communication loop, and proper integration testing of the event flow.

### Approach

I'll integrate all modules using the event bus system by implementing missing event handlers and ensuring proper event flow between modules. The approach focuses on:

- **Missing Event Handlers**: Add handlers for `TaskListRequested`, `TaskActionRequested`, `TaskCreated`, and `TaskCompleted` events
- **Event Flow Integration**: Ensure proper communication between chatbot, LLM, and nudge modules
- **Service Initialization**: Update main.go to properly wire all event subscriptions during startup
- **Response Events**: Add new event types for responses (TaskListResponse) to complete the communication loop
- **Error Handling**: Implement proper error handling and logging for all event handlers

The implementation maintains the existing clean architecture while completing the event-driven communication between all modules.

### Reasoning

I explored the current codebase structure including all three service implementations (chatbot, LLM, nudge), event types, event bus implementation, and main server initialization. I analyzed the existing event subscriptions and handlers to identify what's missing. The analysis revealed that while basic event handling is in place, several key event handlers are missing: TaskListRequested and TaskActionRequested events are published by the chatbot but not handled by the nudge service, and there's no response mechanism for task list requests.

## Mermaid Diagram

sequenceDiagram
    participant User as Telegram User
    participant CB as ChatbotService
    participant EB as EventBus
    participant LLM as LLMService
    participant NS as NudgeService
    participant DB as Database

    Note over User,DB: Complete Event Flow Integration

    Note over User,DB: 1. Task Creation Flow
    User->>CB: Send message "Buy groceries tomorrow"
    CB->>EB: Publish MessageReceived event
    EB->>LLM: Handle MessageReceived
    LLM->>LLM: Parse with Gemma API
    LLM->>EB: Publish TaskParsed event
    EB->>NS: Handle TaskParsed
    NS->>DB: Create task in database
    NS->>EB: Publish TaskCreated event
    EB->>CB: Handle TaskCreated
    CB->>User: Send confirmation with action buttons

    Note over User,DB: 2. Task List Request Flow
    User->>CB: Send /list command
    CB->>EB: Publish TaskListRequested event
    EB->>NS: Handle TaskListRequested
    NS->>DB: Query user tasks
    NS->>EB: Publish TaskListResponse event
    EB->>CB: Handle TaskListResponse
    CB->>User: Send formatted task list with keyboards

    Note over User,DB: 3. Task Action Flow
    User->>CB: Click "Done" button
    CB->>EB: Publish TaskActionRequested event
    EB->>NS: Handle TaskActionRequested
    NS->>DB: Update task status
    NS->>EB: Publish TaskCompleted event
    NS->>EB: Publish TaskActionResponse event
    EB->>CB: Handle TaskActionResponse
    CB->>User: Send action confirmation

    Note over User,DB: 4. Reminder Flow
    NS->>EB: Publish ReminderDue event (scheduled)
    EB->>CB: Handle ReminderDue
    CB->>User: Send reminder with action buttons

    Note over User,DB: 5. Event Bus Integration
    Note over EB: All modules subscribe to relevant events
    Note over EB: Event flow validation and monitoring
    Note over EB: Graceful shutdown with event cleanup

## Proposed File Changes

### internal/events/types.go(MODIFY)

Add new event types to complete the communication loop between modules:

- `TaskListResponse` event with fields: Event (embedded), UserID, ChatID, Tasks (slice of TaskSummary), TotalCount, HasMore for responding to task list requests
- `TaskActionResponse` event with fields: Event (embedded), UserID, ChatID, TaskID, Action, Success, Message for responding to task action requests
- `TaskSummary` struct with fields: ID, Title, Description, DueDate, Priority, Status, IsOverdue for lightweight task representation in responses

Add corresponding topic constants:
- `TopicTaskListResponse = "task.list.response"`
- `TopicTaskActionResponse = "task.action.response"`

These events enable the nudge service to respond to chatbot requests and complete the communication loop. The events follow the same pattern as existing event types and include proper validation tags.

### internal/nudge/service.go(MODIFY)

References: 

- internal/events/types.go(MODIFY)

Add missing event handlers to the nudge service for complete integration:

- Update `setupEventSubscriptions()` method to subscribe to `TaskListRequested` and `TaskActionRequested` events:
  ```go
  // Subscribe to TaskListRequested events from the chatbot
  err = s.eventBus.Subscribe(events.TopicTaskListRequested, s.handleTaskListRequested)
  if err != nil {
      s.logger.Error("Failed to subscribe to TaskListRequested events", zap.Error(err))
  }
  
  // Subscribe to TaskActionRequested events from the chatbot
  err = s.eventBus.Subscribe(events.TopicTaskActionRequested, s.handleTaskActionRequested)
  if err != nil {
      s.logger.Error("Failed to subscribe to TaskActionRequested events", zap.Error(err))
  }
  ```

- Implement `handleTaskListRequested(event events.TaskListRequested)` method that:
  - Retrieves tasks for the user using `GetTasks()` with appropriate filters
  - Converts tasks to `TaskSummary` format for lightweight transmission
  - Publishes `TaskListResponse` event with the task data
  - Handles pagination and filtering
  - Includes proper error handling and logging

- Implement `handleTaskActionRequested(event events.TaskActionRequested)` method that:
  - Processes the requested action (done, delete, snooze) using appropriate service methods
  - Calls `UpdateTaskStatus()`, `DeleteTask()`, or `SnoozeTask()` based on the action
  - Publishes `TaskActionResponse` event with success/failure status
  - Includes detailed error messages for failed actions
  - Handles edge cases like non-existent tasks

Both handlers should maintain the existing error handling patterns and use structured logging. Reference the new event types from `internal/events/types.go`.

### internal/chatbot/service.go(MODIFY)

References: 

- internal/events/types.go(MODIFY)
- internal/chatbot/keyboard_builder.go

Add event handlers for response events from the nudge service:

- Update `setupEventSubscriptions()` method to subscribe to response events:
  ```go
  // Subscribe to TaskListResponse events from the nudge service
  err = s.eventBus.Subscribe(events.TopicTaskListResponse, s.handleTaskListResponse)
  if err != nil {
      s.logger.Error("Failed to subscribe to TaskListResponse events", zap.Error(err))
  }
  
  // Subscribe to TaskActionResponse events from the nudge service
  err = s.eventBus.Subscribe(events.TopicTaskActionResponse, s.handleTaskActionResponse)
  if err != nil {
      s.logger.Error("Failed to subscribe to TaskActionResponse events", zap.Error(err))
  }
  
  // Subscribe to TaskCreated events for confirmation messages
  err = s.eventBus.Subscribe(events.TopicTaskCreated, s.handleTaskCreated)
  if err != nil {
      s.logger.Error("Failed to subscribe to TaskCreated events", zap.Error(err))
  }
  ```

- Implement `handleTaskListResponse(event events.TaskListResponse)` method that:
  - Formats the task list into a user-friendly message with task details
  - Creates inline keyboards for task actions using `keyboardBuilder.BuildTaskListKeyboard()`
  - Sends the formatted message with keyboard to the user
  - Handles empty task lists with appropriate messaging
  - Includes pagination support if needed

- Implement `handleTaskActionResponse(event events.TaskActionResponse)` method that:
  - Sends confirmation or error messages based on the action success status
  - Provides user-friendly feedback for completed actions
  - Handles different action types with appropriate messaging
  - Includes error details for failed actions

- Implement `handleTaskCreated(event events.TaskCreated)` method that:
  - Sends task creation confirmation with task details and action buttons
  - Creates inline keyboard for immediate task actions
  - Replaces the current basic confirmation in `handleTaskParsed`
  - Includes task ID for proper action handling

Update the existing `handleTaskParsed` method to remove the direct message sending since `TaskCreated` events will handle confirmations. Reference the new event types from `internal/events/types.go` and keyboard builder methods.

### cmd/server/main.go(MODIFY)

References: 

- internal/events/types.go(MODIFY)
- internal/events/bus.go

Update the main server initialization to ensure proper event bus integration and add event flow validation:

- After service initialization (around line 61), add event bus health check and subscription validation:
  ```go
  // Validate event bus subscriptions
  logger.Info("Validating event bus subscriptions...")
  
  // Test event publishing to ensure all subscriptions are working
  testEvent := events.NewEvent()
  if err := eventBus.Publish("test.connection", testEvent); err != nil {
      logger.Warn("Event bus test failed", "error", err)
  }
  
  logger.Info("Event bus integration completed",
      "chatbot_subscriptions", "TaskParsed, ReminderDue, TaskListResponse, TaskActionResponse, TaskCreated",
      "llm_subscriptions", "MessageReceived",
      "nudge_subscriptions", "TaskParsed, TaskListRequested, TaskActionRequested")
  ```

- Add a startup delay to ensure all services are fully initialized before processing events:
  ```go
  // Allow services to complete initialization
  time.Sleep(100 * time.Millisecond)
  ```

- Update the graceful shutdown sequence (around line 100) to ensure proper event bus cleanup:
  ```go
  logger.Info("Shutting down server...")
  
  // Stop accepting new events
  logger.Info("Stopping event processing...")
  
  // Close event bus with timeout
  eventBusCtx, eventBusCancel := context.WithTimeout(context.Background(), 10*time.Second)
  defer eventBusCancel()
  
  go func() {
      if err := eventBus.Close(); err != nil {
          logger.Error("Failed to close event bus", "error", err)
      }
  }()
  
  select {
  case <-eventBusCtx.Done():
      logger.Warn("Event bus shutdown timed out")
  case <-time.After(5*time.Second):
      logger.Info("Event bus closed successfully")
  }
  ```

The changes ensure that all modules are properly integrated through the event bus and provide better observability of the event-driven architecture during startup and shutdown.

### internal/events/integration.go(NEW)

References: 

- internal/events/types.go(MODIFY)
- internal/events/bus.go

Create an integration utility for testing and validating event flow between modules:

- Implement `EventFlowValidator` struct with methods for testing event propagation:
  - `ValidateMessageToTaskFlow(eventBus, userID, chatID, messageText)` that simulates the complete flow from message to task creation
  - `ValidateTaskActionFlow(eventBus, userID, chatID, taskID, action)` that tests task action processing
  - `ValidateTaskListFlow(eventBus, userID, chatID)` that tests task list retrieval
  - `ValidateReminderFlow(eventBus, taskID, userID, chatID)` that tests reminder notifications

- Implement `EventFlowMonitor` struct for runtime monitoring:
  - Track event publishing and subscription metrics
  - Monitor event processing latency
  - Detect failed event deliveries
  - Provide health check endpoints for event system status

- Include helper functions:
  - `WaitForEvent(eventBus, topic, timeout)` for testing event delivery
  - `CreateTestEvents()` for generating test event data
  - `ValidateEventStructure(event)` for ensuring event data integrity

- Add integration test utilities:
  - Mock event handlers for testing
  - Event capture mechanisms for verification
  - Timeout handling for async event processing

The integration utilities will help ensure the event-driven architecture works correctly and provide debugging capabilities for event flow issues. Reference all event types from `internal/events/types.go` and the event bus interface from `internal/events/bus.go`.

### internal/mocks/event_mocks.go(NEW)

References: 

- internal/events/bus.go
- internal/events/types.go(MODIFY)

Create comprehensive mock implementations for testing event integration:

- Add `//go:generate mockgen -source=../events/bus.go -destination=event_bus_mocks.go -package=mocks` directive for generating event bus mocks

- Implement `MockEventBus` struct with in-memory event handling:
  - `subscriptions map[string][]interface{}` for tracking subscribers
  - `publishedEvents map[string][]interface{}` for capturing published events
  - `mutex sync.RWMutex` for thread safety
  - Methods that implement the EventBus interface with full functionality

- Implement helper methods for testing:
  - `GetPublishedEvents(topic string) []interface{}` for retrieving published events
  - `GetSubscriberCount(topic string) int` for checking subscription counts
  - `ClearEvents()` for resetting state between tests
  - `WaitForEvent(topic string, timeout time.Duration) (interface{}, error)` for async event testing
  - `SimulateEventDelivery(topic string, event interface{})` for triggering event handlers

- Implement `MockEventHandler` struct for testing event processing:
  - Configurable response behavior (success, error, delay)
  - Call tracking and verification
  - Event data validation

- Include factory methods for creating test scenarios:
  - `CreateMessageReceivedEvent(userID, chatID, text)` for testing message flow
  - `CreateTaskParsedEvent(userID, taskData)` for testing task creation
  - `CreateReminderDueEvent(taskID, userID, chatID)` for testing reminders
  - `CreateTaskActionEvent(userID, chatID, taskID, action)` for testing task actions

- Add assertion helpers:
  - `AssertEventPublished(t *testing.T, topic string, expectedEvent interface{})`
  - `AssertEventCount(t *testing.T, topic string, expectedCount int)`
  - `AssertEventHandlerCalled(t *testing.T, handler *MockEventHandler, expectedCalls int)`

The mocks will enable comprehensive testing of the event-driven architecture and help verify that all modules are properly integrated. Reference the event bus interface from `internal/events/bus.go` and all event types from `internal/events/types.go`.

### internal/common/event_utils.go(NEW)

References: 

- internal/events/types.go(MODIFY)
- internal/nudge/domain.go

Create utility functions for common event operations across modules:

- Implement `EventPublisher` helper struct with methods:
  - `PublishWithRetry(eventBus, topic, event, maxRetries)` for reliable event publishing with exponential backoff
  - `PublishBatch(eventBus, events)` for publishing multiple events efficiently
  - `PublishWithCorrelation(eventBus, topic, event, correlationID)` for maintaining correlation across event chains

- Implement `EventValidator` utility with methods:
  - `ValidateEventStructure(event interface{}) error` for ensuring events have required fields
  - `ValidateCorrelationID(correlationID string) error` for correlation ID format validation
  - `ValidateUserPermissions(userID, action string) error` for basic authorization checks

- Implement `EventMetrics` utility for monitoring:
  - `RecordEventPublished(topic string, success bool)` for tracking publication metrics
  - `RecordEventProcessed(topic string, duration time.Duration)` for performance monitoring
  - `RecordEventError(topic string, error error)` for error tracking

- Include helper functions:
  - `ExtractUserContext(event interface{}) (userID, chatID string, err error)` for getting user info from events
  - `CreateCorrelationChain(parentEvent interface{}) string` for linking related events
  - `FormatEventForLogging(event interface{}) map[string]interface{}` for structured logging
  - `IsRetryableError(err error) bool` for determining if event processing should be retried

- Add event transformation utilities:
  - `ConvertTaskToSummary(task *Task) TaskSummary` for converting between domain models and event payloads
  - `ConvertParsedTaskToTask(parsedTask ParsedTask, userID string) *Task` for domain model conversion
  - `ExtractTaskMetadata(event interface{}) (taskID, userID string, err error)` for metadata extraction

These utilities will reduce code duplication across modules and provide consistent event handling patterns. Reference the event types from `internal/events/types.go` and domain models from the respective modules.